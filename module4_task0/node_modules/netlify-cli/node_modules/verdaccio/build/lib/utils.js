"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorCode = void 0;
exports.addGravatarSupport = addGravatarSupport;
exports.addScope = addScope;
exports.buildToken = buildToken;
exports.combineBaseUrl = combineBaseUrl;
exports.convertDistRemoteToLocalTarballUrls = convertDistRemoteToLocalTarballUrls;
exports.convertPayloadToBase64 = convertPayloadToBase64;
exports.deleteProperties = deleteProperties;
exports.encodeScopedUri = encodeScopedUri;
exports.extractTarballFromUrl = extractTarballFromUrl;
exports.fileExists = fileExists;
exports.folderExists = folderExists;
exports.formatAuthor = formatAuthor;
exports.getLatestVersion = getLatestVersion;
exports.getLocalRegistryTarballUri = getLocalRegistryTarballUri;
exports.getPublicUrl = getPublicUrl;
exports.getUserAgent = getUserAgent;
exports.getVersion = getVersion;
exports.getVersionFromTarball = getVersionFromTarball;
exports.getWebProtocol = getWebProtocol;
exports.hasDiffOneKey = hasDiffOneKey;
exports.hasLogin = hasLogin;
exports.isHTTPProtocol = isHTTPProtocol;
exports.isHost = isHost;
exports.isObject = isObject;
exports.isObjectOrArray = isObjectOrArray;
exports.isRelatedToDeprecation = isRelatedToDeprecation;
exports.isVersionValid = isVersionValid;
exports.mask = mask;
exports.normalizeDistTags = normalizeDistTags;
exports.pad = pad;
exports.parseAddress = parseAddress;
exports.parseConfigFile = parseConfigFile;
exports.parseInterval = parseInterval;
exports.parseReadme = parseReadme;
exports.semverSort = semverSort;
exports.sortByName = sortByName;
exports.tagVersion = tagVersion;
exports.validateMetadata = validateMetadata;
exports.validateName = validateName;
exports.validatePackage = validatePackage;
exports.validateURL = validateURL;
exports.wrapPrefix = wrapPrefix;
var _assert = _interopRequireDefault(require("assert"));
var _debug = _interopRequireDefault(require("debug"));
var _fs = _interopRequireDefault(require("fs"));
var _jsYaml = _interopRequireDefault(require("js-yaml"));
var _lodash = _interopRequireDefault(require("lodash"));
var _memoizee = _interopRequireDefault(require("memoizee"));
var _semver = _interopRequireDefault(require("semver"));
var _url = _interopRequireWildcard(require("url"));
var _validator = _interopRequireDefault(require("validator"));
var _commonsApi = require("@verdaccio/commons-api");
var _user = require("../utils/user");
var _constants = require("./constants");
var _logger = require("./logger");
var _storageUtils = require("./storage-utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const debug = (0, _debug.default)('verdaccio');

// eslint-disable-next-line @typescript-eslint/no-unused-vars
// eslint-disable-next-line @typescript-eslint/no-var-requires
require('pkginfo')(module);
const pkgVersion = module.exports.version;
const pkgName = module.exports.name;
const validProtocols = ['https', 'http'];
function getUserAgent(customUserAgent) {
  (0, _assert.default)(_lodash.default.isString(pkgName));
  (0, _assert.default)(_lodash.default.isString(pkgVersion));
  if (customUserAgent === true) {
    return `${pkgName}/${pkgVersion}`;
  } else if (_lodash.default.isString(customUserAgent) && _lodash.default.isEmpty(customUserAgent) === false) {
    return customUserAgent;
  } else if (customUserAgent === false) {
    return '';
  }
  return `${pkgName}/${pkgVersion}`;
}
function convertPayloadToBase64(payload) {
  return Buffer.from(payload, 'base64');
}

/**
 * From normalize-package-data/lib/fixer.js
 * @param {*} name  the package name
 * @return {Boolean} whether is valid or not
 */
function validateName(name) {
  if (_lodash.default.isString(name) === false) {
    return false;
  }
  const normalizedName = name.toLowerCase();

  /**
   * Some context about the first regex
   * - npm used to have a different tarball naming system.
   * eg: http://registry.npmjs.com/thirty-two
   * https://registry.npmjs.org/thirty-two/-/thirty-two@0.0.1.tgz
   * The file name thirty-two@0.0.1.tgz, the version and the pkg name was separated by an at (@)
   * while nowadays the naming system is based in dashes
   * https://registry.npmjs.org/verdaccio/-/verdaccio-1.4.0.tgz
   *
   * more info here: https://github.com/rlidwka/sinopia/issues/75
   */
  return !(!normalizedName.match(/^[-a-zA-Z0-9_.!~*'()@]+$/) || normalizedName.startsWith('.') ||
  // ".bin", etc.
  ['node_modules', '__proto__', 'favicon.ico'].includes(normalizedName));
}

/**
 * Validate a package.
 * @return {Boolean} whether the package is valid or not
 */
function validatePackage(name) {
  const nameList = name.split('/', 2);
  if (nameList.length === 1) {
    // normal package
    return validateName(nameList[0]);
  }
  // scoped package
  return nameList[0][0] === '@' && validateName(nameList[0].slice(1)) && validateName(nameList[1]);
}

/**
 * Check whether an element is an Object
 * @param {*} obj the element
 * @return {Boolean}
 */
function isObject(obj) {
  return _lodash.default.isObject(obj) && _lodash.default.isNull(obj) === false && _lodash.default.isArray(obj) === false;
}
function isObjectOrArray(obj) {
  return _lodash.default.isObject(obj) && _lodash.default.isNull(obj) === false;
}

/**
 * Validate the package metadata, add additional properties whether are missing within
 * the metadata properties.
 * @param {*} object
 * @param {*} name
 * @return {Object} the object with additional properties as dist-tags ad versions
 */
function validateMetadata(object, name) {
  (0, _assert.default)(isObject(object), 'not a json object');
  _assert.default.strictEqual(object.name, name);
  if (!isObject(object[_constants.DIST_TAGS])) {
    object[_constants.DIST_TAGS] = {};
  }
  if (!isObject(object['versions'])) {
    object['versions'] = {};
  }
  if (!isObject(object['time'])) {
    object['time'] = {};
  }
  return object;
}
function extractTarballFromUrl(url) {
  // @ts-ignore
  return _url.default.parse(url).pathname.replace(/^.*\//, '');
}

/**
 * Iterate a packages's versions and filter each original tarball url.
 * @param {*} pkg
 * @param {*} req
 * @param {*} config
 * @return {String} a filtered package
 */
function convertDistRemoteToLocalTarballUrls(pkg, req, urlPrefix) {
  for (const ver in pkg.versions) {
    if (Object.prototype.hasOwnProperty.call(pkg.versions, ver)) {
      const distName = pkg.versions[ver].dist;
      if (_lodash.default.isNull(distName) === false && _lodash.default.isNull(distName.tarball) === false) {
        distName.tarball = getLocalRegistryTarballUri(distName.tarball, pkg.name, req, urlPrefix);
      }
    }
  }
  return pkg;
}
const memoizedgetPublicUrl = (0, _memoizee.default)(getPublicUrl);

/**
 * Filter a tarball url.
 * @param {*} uri
 * @return {String} a parsed url
 */
function getLocalRegistryTarballUri(uri, pkgName, req, urlPrefix) {
  const currentHost = req.get('host');
  if (!currentHost) {
    return uri;
  }
  const tarballName = extractTarballFromUrl(uri);
  const domainRegistry = memoizedgetPublicUrl(urlPrefix || '', req);
  return `${domainRegistry}${encodeScopedUri(pkgName)}/-/${tarballName}`;
}
function tagVersion(data, version, tag) {
  if (tag && data[_constants.DIST_TAGS][tag] !== version && _semver.default.parse(version, true)) {
    // valid version - store
    data[_constants.DIST_TAGS][tag] = version;
    return true;
  }
  return false;
}

/**
 * Gets version from a package object taking into account semver weirdness.
 * @return {String} return the semantic version of a package
 */
function getVersion(pkg, version) {
  // this condition must allow cast
  if (_lodash.default.isNil(pkg.versions[version]) === false) {
    return pkg.versions[version];
  }
  try {
    version = _semver.default.parse(version, true);
    for (const versionItem in pkg.versions) {
      // $FlowFixMe
      if (version.compare(_semver.default.parse(versionItem, true)) === 0) {
        return pkg.versions[versionItem];
      }
    }
  } catch (err) {
    return undefined;
  }
}

/**
 * Parse an internet address
 * Allow:
 - https:localhost:1234        - protocol + host + port
 - localhost:1234              - host + port
 - 1234                        - port
 - http::1234                  - protocol + port
 - https://localhost:443/      - full url + https
 - http://[::1]:443/           - ipv6
 - unix:/tmp/http.sock         - unix sockets
 - https://unix:/tmp/http.sock - unix sockets (https)
 * @param {*} urlAddress the internet address definition
 * @return {Object|Null} literal object that represent the address parsed
 */
function parseAddress(urlAddress) {
  //
  // TODO: refactor it to something more reasonable?
  //
  //        protocol :  //      (  host  )|(    ipv6     ):  port  /
  let urlPattern = /^((https?):(\/\/)?)?((([^\/:]*)|\[([^\[\]]+)\]):)?(\d+)\/?$/.exec(urlAddress);
  if (urlPattern) {
    return {
      proto: urlPattern[2] || _constants.DEFAULT_PROTOCOL,
      host: urlPattern[6] || urlPattern[7] || _constants.DEFAULT_DOMAIN,
      port: urlPattern[8] || _constants.DEFAULT_PORT
    };
  }
  urlPattern = /^((https?):(\/\/)?)?unix:(.*)$/.exec(urlAddress);
  if (urlPattern) {
    return {
      proto: urlPattern[2] || _constants.DEFAULT_PROTOCOL,
      path: urlPattern[4]
    };
  }
  return null;
}

/**
 * Function filters out bad semver versions and sorts the array.
 * @return {Array} sorted Array
 */
function semverSort(listVersions) {
  return listVersions.filter(function (x) {
    if (!_semver.default.parse(x, true)) {
      _logger.logger.warn({
        ver: x
      }, 'ignoring bad version @{ver}');
      return false;
    }
    return true;
  })
  // FIXME: it seems the @types/semver do not handle a legitimate method named 'compareLoose'
  // @ts-ignore
  .sort(_semver.default.compareLoose).map(String);
}

/**
 * Flatten arrays of tags.
 * @param {*} data
 */
function normalizeDistTags(pkg) {
  let sorted;
  if (!pkg[_constants.DIST_TAGS].latest) {
    // overwrite latest with highest known version based on semver sort
    sorted = semverSort(Object.keys(pkg.versions));
    if (sorted && sorted.length) {
      pkg[_constants.DIST_TAGS].latest = sorted.pop();
    }
  }
  for (const tag in pkg[_constants.DIST_TAGS]) {
    if (_lodash.default.isArray(pkg[_constants.DIST_TAGS][tag])) {
      if (pkg[_constants.DIST_TAGS][tag].length) {
        // sort array
        // FIXME: this is clearly wrong, we need to research why this is like this.
        // @ts-ignore
        sorted = semverSort(pkg[_constants.DIST_TAGS][tag]);
        if (sorted.length) {
          // use highest version based on semver sort
          pkg[_constants.DIST_TAGS][tag] = sorted.pop();
        }
      } else {
        delete pkg[_constants.DIST_TAGS][tag];
      }
    } else if (_lodash.default.isString(pkg[_constants.DIST_TAGS][tag])) {
      if (!_semver.default.parse(pkg[_constants.DIST_TAGS][tag], true)) {
        // if the version is invalid, delete the dist-tag entry
        delete pkg[_constants.DIST_TAGS][tag];
      }
    }
  }
}
const parseIntervalTable = {
  '': 1000,
  ms: 1,
  s: 1000,
  m: 60 * 1000,
  h: 60 * 60 * 1000,
  d: 86400000,
  w: 7 * 86400000,
  M: 30 * 86400000,
  y: 365 * 86400000
};

/**
 * Parse an internal string to number
 * @param {*} interval
 * @return {Number}
 */
function parseInterval(interval) {
  if (typeof interval === 'number') {
    return interval * 1000;
  }
  let result = 0;
  let last_suffix = Infinity;
  interval.split(/\s+/).forEach(function (x) {
    if (!x) {
      return;
    }
    const m = x.match(/^((0|[1-9][0-9]*)(\.[0-9]+)?)(ms|s|m|h|d|w|M|y|)$/);
    if (!m || parseIntervalTable[m[4]] >= last_suffix || m[4] === '' && last_suffix !== Infinity) {
      throw Error('invalid interval: ' + interval);
    }
    last_suffix = parseIntervalTable[m[4]];
    result += Number(m[1]) * parseIntervalTable[m[4]];
  });
  return result;
}

/**
 * Detect running protocol (http or https)
 */
function getWebProtocol(headerProtocol, protocol) {
  let returnProtocol;
  const [, defaultProtocol] = validProtocols;
  // HAProxy variant might return http,http with X-Forwarded-Proto
  if (typeof headerProtocol === 'string' && headerProtocol !== '') {
    debug('header protocol: %o', protocol);
    const commaIndex = headerProtocol.indexOf(',');
    returnProtocol = commaIndex > 0 ? headerProtocol.substr(0, commaIndex) : headerProtocol;
  } else {
    debug('req protocol: %o', headerProtocol);
    returnProtocol = protocol;
  }
  return validProtocols.includes(returnProtocol) ? returnProtocol : defaultProtocol;
}
function getLatestVersion(pkgInfo) {
  return pkgInfo[_constants.DIST_TAGS].latest;
}
const ErrorCode = {
  getConflict: _commonsApi.getConflict,
  getBadData: _commonsApi.getBadData,
  getBadRequest: _commonsApi.getBadRequest,
  getInternalError: _commonsApi.getInternalError,
  getUnauthorized: _commonsApi.getUnauthorized,
  getForbidden: _commonsApi.getForbidden,
  getServiceUnavailable: _commonsApi.getServiceUnavailable,
  getNotFound: _commonsApi.getNotFound,
  getCode: _commonsApi.getCode
};
exports.ErrorCode = ErrorCode;
function parseConfigFile(configPath) {
  try {
    if (/\.ya?ml$/i.test(configPath)) {
      return _jsYaml.default.load(_fs.default.readFileSync(configPath, 'utf-8'));
    }
    debug('yaml parsed');
    return require(configPath);
  } catch (e) {
    debug('yaml parse failed');
    if (e.code !== 'MODULE_NOT_FOUND') {
      e.message = _constants.APP_ERROR.CONFIG_NOT_VALID;
    }
    throw new Error(e);
  }
}

/**
 * Check whether the path already exist.
 * @param {String} path
 * @return {Boolean}
 */
function folderExists(path) {
  try {
    const stat = _fs.default.statSync(path);
    return stat.isDirectory();
  } catch (_) {
    return false;
  }
}

/**
 * Check whether the file already exist.
 * @param {String} path
 * @return {Boolean}
 */
function fileExists(path) {
  try {
    const stat = _fs.default.statSync(path);
    return stat.isFile();
  } catch (_) {
    return false;
  }
}
function sortByName(packages, orderAscending = true) {
  return packages.slice().sort(function (a, b) {
    const comparatorNames = a.name.toLowerCase() < b.name.toLowerCase();
    return orderAscending ? comparatorNames ? -1 : 1 : comparatorNames ? 1 : -1;
  });
}
function addScope(scope, packageName) {
  return `@${scope}/${packageName}`;
}
function deleteProperties(propertiesToDelete, objectItem) {
  _lodash.default.forEach(propertiesToDelete, property => {
    delete objectItem[property];
  });
  return objectItem;
}
function addGravatarSupport(pkgInfo, online = true) {
  const pkgInfoCopy = _objectSpread({}, pkgInfo);
  const author = _lodash.default.get(pkgInfo, 'latest.author', null);
  const contributors = (0, _storageUtils.normalizeContributors)(_lodash.default.get(pkgInfo, 'latest.contributors', []));
  const maintainers = _lodash.default.get(pkgInfo, 'latest.maintainers', []);

  // for author.
  if (author && _lodash.default.isObject(author)) {
    const {
      email
    } = author;
    pkgInfoCopy.latest.author.avatar = (0, _user.generateGravatarUrl)(email, online);
  }
  if (author && _lodash.default.isString(author)) {
    pkgInfoCopy.latest.author = {
      avatar: _user.GENERIC_AVATAR,
      email: '',
      author
    };
  }

  // for contributors
  if (_lodash.default.isEmpty(contributors) === false) {
    pkgInfoCopy.latest.contributors = contributors.map(contributor => {
      if (isObject(contributor)) {
        contributor.avatar = (0, _user.generateGravatarUrl)(contributor.email, online);
      } else if (_lodash.default.isString(contributor)) {
        contributor = {
          avatar: _user.GENERIC_AVATAR,
          email: contributor,
          name: contributor
        };
      }
      return contributor;
    });
  }

  // for maintainers
  if (_lodash.default.isEmpty(maintainers) === false) {
    pkgInfoCopy.latest.maintainers = maintainers.map(maintainer => {
      maintainer.avatar = (0, _user.generateGravatarUrl)(maintainer.email, online);
      return maintainer;
    });
  }
  return pkgInfoCopy;
}

/**
 * parse package readme - markdown/ascii
 * @param {String} packageName name of package
 * @param {String} readme package readme

 * @return {String} converted html template
 */
function parseReadme(packageName, readme) {
  if (_lodash.default.isEmpty(readme) === false) {
    return readme;
  }

  // logs readme not found error
  _logger.logger.info({
    packageName
  }, '@{packageName}: No readme found');
  return 'ERROR: No README data found!';
}
function buildToken(type, token) {
  return `${_lodash.default.capitalize(type)} ${token}`;
}

/**
 * return package version from tarball name
 * @param {String} name
 * @returns {String}
 */
function getVersionFromTarball(name) {
  // FIXME: we know the regex is valid, but we should improve this part as ts suggest
  // @ts-ignore
  return /.+-(\d.+)\.tgz/.test(name) ? name.match(/.+-(\d.+)\.tgz/)[1] : undefined;
}
/**
 * Formats author field for webui.
 * @see https://docs.npmjs.com/files/package.json#author
 * @param {string|object|undefined} author
 */
function formatAuthor(author) {
  let authorDetails = {
    name: _constants.DEFAULT_USER,
    email: '',
    url: ''
  };
  if (_lodash.default.isNil(author)) {
    return authorDetails;
  }
  if (_lodash.default.isString(author)) {
    authorDetails = _objectSpread(_objectSpread({}, authorDetails), {}, {
      name: author
    });
  }
  if (_lodash.default.isObject(author)) {
    authorDetails = _objectSpread(_objectSpread({}, authorDetails), author);
  }
  return authorDetails;
}

/**
 * Check if URI is starting with "http://", "https://" or "//"
 * @param {string} uri
 */
function isHTTPProtocol(uri) {
  return /^(https?:)?\/\//.test(uri);
}

/**
 * Apply whitespaces based on the length
 * @param {*} str the log message
 * @return {String}
 */
function pad(str, max) {
  if (str.length < max) {
    return str + ' '.repeat(max - str.length);
  }
  return str;
}

/**
 * return a masquerade string with its first and last {charNum} and three dots in between.
 * @param {String} str
 * @param {Number} charNum
 * @returns {String}
 */
function mask(str, charNum = 3) {
  return `${str.substr(0, charNum)}...${str.substr(-charNum)}`;
}
function encodeScopedUri(packageName) {
  return packageName.replace(/\//g, '%2f');
}
function hasDiffOneKey(versions) {
  return Object.keys(versions).length !== 1;
}
function isVersionValid(packageMeta, packageVersion) {
  const hasVersion = typeof packageVersion !== 'undefined';
  if (!hasVersion) {
    return false;
  }
  const hasMatchVersion = Object.keys(packageMeta.versions).includes(packageVersion);
  return hasMatchVersion;
}
function isRelatedToDeprecation(pkgInfo) {
  const {
    versions
  } = pkgInfo;
  for (const version in versions) {
    if (Object.prototype.hasOwnProperty.call(versions[version], 'deprecated')) {
      return true;
    }
  }
  return false;
}
function validateURL(publicUrl) {
  try {
    const parsed = new _url.URL(publicUrl);
    if (!validProtocols.includes(parsed.protocol.replace(':', ''))) {
      throw Error('invalid protocol');
    }
    return true;
  } catch (err) {
    // TODO: add error logger here
    return false;
  }
}
function isHost(url = '', options = {}) {
  return _validator.default.isURL(url, _objectSpread({
    require_host: true,
    allow_trailing_dot: false,
    require_valid_protocol: false,
    // @ts-ignore
    require_port: false,
    require_tld: false
  }, options));
}
function getPublicUrl(url_prefix = '', req) {
  if (validateURL(process.env.VERDACCIO_PUBLIC_URL)) {
    const envURL = new _url.URL(wrapPrefix(url_prefix), process.env.VERDACCIO_PUBLIC_URL).href;
    debug('public url by env %o', envURL);
    return envURL;
  } else if (req.get('host')) {
    var _process$env$VERDACCI;
    const host = req.get('host');
    if (!isHost(host)) {
      throw new Error('invalid host');
    }
    const protoHeader = (_process$env$VERDACCI = process.env.VERDACCIO_FORWARDED_PROTO) !== null && _process$env$VERDACCI !== void 0 ? _process$env$VERDACCI : _constants.HEADERS.FORWARDED_PROTO;
    const protocol = getWebProtocol(req.get(protoHeader.toLowerCase()), req.protocol);
    const combinedUrl = combineBaseUrl(protocol, host, url_prefix);
    debug('public url by request %o', combinedUrl);
    return combinedUrl;
  } else {
    return '/';
  }
}

/**
 * Create base url for registry.
 * @return {String} base registry url
 */
function combineBaseUrl(protocol, host, prefix = '') {
  debug('combined protocol %o', protocol);
  debug('combined host %o', host);
  const newPrefix = wrapPrefix(prefix);
  debug('combined prefix %o', newPrefix);
  const groupedURI = new _url.URL(wrapPrefix(prefix), `${protocol}://${host}`);
  const result = groupedURI.href;
  debug('combined url %o', result);
  return result;
}
function wrapPrefix(prefix) {
  if (prefix === '' || typeof prefix === 'undefined' || prefix === null) {
    return '';
  } else if (!prefix.startsWith('/') && prefix.endsWith('/')) {
    return `/${prefix}`;
  } else if (!prefix.startsWith('/') && !prefix.endsWith('/')) {
    return `/${prefix}/`;
  } else if (prefix.startsWith('/') && !prefix.endsWith('/')) {
    return `${prefix}/`;
  } else {
    return prefix;
  }
}
function hasLogin(config) {
  var _config$web, _config$web2;
  // FIXME: types are not yet on the library verdaccio/monorepo
  // @ts-ignore
  return _lodash.default.isNil(config === null || config === void 0 ? void 0 : (_config$web = config.web) === null || _config$web === void 0 ? void 0 : _config$web.login) || (config === null || config === void 0 ? void 0 : (_config$web2 = config.web) === null || _config$web2 === void 0 ? void 0 : _config$web2.login) === true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1ZyIsImJ1aWxkRGVidWciLCJyZXF1aXJlIiwibW9kdWxlIiwicGtnVmVyc2lvbiIsImV4cG9ydHMiLCJ2ZXJzaW9uIiwicGtnTmFtZSIsIm5hbWUiLCJ2YWxpZFByb3RvY29scyIsImdldFVzZXJBZ2VudCIsImN1c3RvbVVzZXJBZ2VudCIsImFzc2VydCIsIl8iLCJpc1N0cmluZyIsImlzRW1wdHkiLCJjb252ZXJ0UGF5bG9hZFRvQmFzZTY0IiwicGF5bG9hZCIsIkJ1ZmZlciIsImZyb20iLCJ2YWxpZGF0ZU5hbWUiLCJub3JtYWxpemVkTmFtZSIsInRvTG93ZXJDYXNlIiwibWF0Y2giLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJ2YWxpZGF0ZVBhY2thZ2UiLCJuYW1lTGlzdCIsInNwbGl0IiwibGVuZ3RoIiwic2xpY2UiLCJpc09iamVjdCIsIm9iaiIsImlzTnVsbCIsImlzQXJyYXkiLCJpc09iamVjdE9yQXJyYXkiLCJ2YWxpZGF0ZU1ldGFkYXRhIiwib2JqZWN0Iiwic3RyaWN0RXF1YWwiLCJESVNUX1RBR1MiLCJleHRyYWN0VGFyYmFsbEZyb21VcmwiLCJ1cmwiLCJEZWZhdWx0VVJMIiwicGFyc2UiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJjb252ZXJ0RGlzdFJlbW90ZVRvTG9jYWxUYXJiYWxsVXJscyIsInBrZyIsInJlcSIsInVybFByZWZpeCIsInZlciIsInZlcnNpb25zIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGlzdE5hbWUiLCJkaXN0IiwidGFyYmFsbCIsImdldExvY2FsUmVnaXN0cnlUYXJiYWxsVXJpIiwibWVtb2l6ZWRnZXRQdWJsaWNVcmwiLCJtZW1vaXplZSIsImdldFB1YmxpY1VybCIsInVyaSIsImN1cnJlbnRIb3N0IiwiZ2V0IiwidGFyYmFsbE5hbWUiLCJkb21haW5SZWdpc3RyeSIsImVuY29kZVNjb3BlZFVyaSIsInRhZ1ZlcnNpb24iLCJkYXRhIiwidGFnIiwic2VtdmVyIiwiZ2V0VmVyc2lvbiIsImlzTmlsIiwidmVyc2lvbkl0ZW0iLCJjb21wYXJlIiwiZXJyIiwidW5kZWZpbmVkIiwicGFyc2VBZGRyZXNzIiwidXJsQWRkcmVzcyIsInVybFBhdHRlcm4iLCJleGVjIiwicHJvdG8iLCJERUZBVUxUX1BST1RPQ09MIiwiaG9zdCIsIkRFRkFVTFRfRE9NQUlOIiwicG9ydCIsIkRFRkFVTFRfUE9SVCIsInBhdGgiLCJzZW12ZXJTb3J0IiwibGlzdFZlcnNpb25zIiwiZmlsdGVyIiwieCIsImxvZ2dlciIsIndhcm4iLCJzb3J0IiwiY29tcGFyZUxvb3NlIiwibWFwIiwiU3RyaW5nIiwibm9ybWFsaXplRGlzdFRhZ3MiLCJzb3J0ZWQiLCJsYXRlc3QiLCJrZXlzIiwicG9wIiwicGFyc2VJbnRlcnZhbFRhYmxlIiwibXMiLCJzIiwibSIsImgiLCJkIiwidyIsIk0iLCJ5IiwicGFyc2VJbnRlcnZhbCIsImludGVydmFsIiwicmVzdWx0IiwibGFzdF9zdWZmaXgiLCJJbmZpbml0eSIsImZvckVhY2giLCJFcnJvciIsIk51bWJlciIsImdldFdlYlByb3RvY29sIiwiaGVhZGVyUHJvdG9jb2wiLCJwcm90b2NvbCIsInJldHVyblByb3RvY29sIiwiZGVmYXVsdFByb3RvY29sIiwiY29tbWFJbmRleCIsImluZGV4T2YiLCJzdWJzdHIiLCJnZXRMYXRlc3RWZXJzaW9uIiwicGtnSW5mbyIsIkVycm9yQ29kZSIsImdldENvbmZsaWN0IiwiZ2V0QmFkRGF0YSIsImdldEJhZFJlcXVlc3QiLCJnZXRJbnRlcm5hbEVycm9yIiwiZ2V0VW5hdXRob3JpemVkIiwiZ2V0Rm9yYmlkZGVuIiwiZ2V0U2VydmljZVVuYXZhaWxhYmxlIiwiZ2V0Tm90Rm91bmQiLCJnZXRDb2RlIiwicGFyc2VDb25maWdGaWxlIiwiY29uZmlnUGF0aCIsInRlc3QiLCJZQU1MIiwibG9hZCIsImZzIiwicmVhZEZpbGVTeW5jIiwiZSIsImNvZGUiLCJtZXNzYWdlIiwiQVBQX0VSUk9SIiwiQ09ORklHX05PVF9WQUxJRCIsImZvbGRlckV4aXN0cyIsInN0YXQiLCJzdGF0U3luYyIsImlzRGlyZWN0b3J5IiwiZmlsZUV4aXN0cyIsImlzRmlsZSIsInNvcnRCeU5hbWUiLCJwYWNrYWdlcyIsIm9yZGVyQXNjZW5kaW5nIiwiYSIsImIiLCJjb21wYXJhdG9yTmFtZXMiLCJhZGRTY29wZSIsInNjb3BlIiwicGFja2FnZU5hbWUiLCJkZWxldGVQcm9wZXJ0aWVzIiwicHJvcGVydGllc1RvRGVsZXRlIiwib2JqZWN0SXRlbSIsInByb3BlcnR5IiwiYWRkR3JhdmF0YXJTdXBwb3J0Iiwib25saW5lIiwicGtnSW5mb0NvcHkiLCJhdXRob3IiLCJjb250cmlidXRvcnMiLCJub3JtYWxpemVDb250cmlidXRvcnMiLCJtYWludGFpbmVycyIsImVtYWlsIiwiYXZhdGFyIiwiZ2VuZXJhdGVHcmF2YXRhclVybCIsIkdFTkVSSUNfQVZBVEFSIiwiY29udHJpYnV0b3IiLCJtYWludGFpbmVyIiwicGFyc2VSZWFkbWUiLCJyZWFkbWUiLCJpbmZvIiwiYnVpbGRUb2tlbiIsInR5cGUiLCJ0b2tlbiIsImNhcGl0YWxpemUiLCJnZXRWZXJzaW9uRnJvbVRhcmJhbGwiLCJmb3JtYXRBdXRob3IiLCJhdXRob3JEZXRhaWxzIiwiREVGQVVMVF9VU0VSIiwiaXNIVFRQUHJvdG9jb2wiLCJwYWQiLCJzdHIiLCJtYXgiLCJyZXBlYXQiLCJtYXNrIiwiY2hhck51bSIsImhhc0RpZmZPbmVLZXkiLCJpc1ZlcnNpb25WYWxpZCIsInBhY2thZ2VNZXRhIiwicGFja2FnZVZlcnNpb24iLCJoYXNWZXJzaW9uIiwiaGFzTWF0Y2hWZXJzaW9uIiwiaXNSZWxhdGVkVG9EZXByZWNhdGlvbiIsInZhbGlkYXRlVVJMIiwicHVibGljVXJsIiwicGFyc2VkIiwiVVJMIiwiaXNIb3N0Iiwib3B0aW9ucyIsInZhbGlkYXRvciIsImlzVVJMIiwicmVxdWlyZV9ob3N0IiwiYWxsb3dfdHJhaWxpbmdfZG90IiwicmVxdWlyZV92YWxpZF9wcm90b2NvbCIsInJlcXVpcmVfcG9ydCIsInJlcXVpcmVfdGxkIiwidXJsX3ByZWZpeCIsInByb2Nlc3MiLCJlbnYiLCJWRVJEQUNDSU9fUFVCTElDX1VSTCIsImVudlVSTCIsIndyYXBQcmVmaXgiLCJocmVmIiwicHJvdG9IZWFkZXIiLCJWRVJEQUNDSU9fRk9SV0FSREVEX1BST1RPIiwiSEVBREVSUyIsIkZPUldBUkRFRF9QUk9UTyIsImNvbWJpbmVkVXJsIiwiY29tYmluZUJhc2VVcmwiLCJwcmVmaXgiLCJuZXdQcmVmaXgiLCJncm91cGVkVVJJIiwiZW5kc1dpdGgiLCJoYXNMb2dpbiIsImNvbmZpZyIsIndlYiIsImxvZ2luIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgYnVpbGREZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSAnZXhwcmVzcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IFlBTUwgZnJvbSAnanMteWFtbCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IG1lbW9pemVlIGZyb20gJ21lbW9pemVlJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCBEZWZhdWx0VVJMLCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJ3ZhbGlkYXRvcic7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5pbXBvcnQgeyBnZXRCYWREYXRhLCBnZXRCYWRSZXF1ZXN0LCBnZXRDb2RlLCBnZXRDb25mbGljdCwgZ2V0Rm9yYmlkZGVuLCBnZXRJbnRlcm5hbEVycm9yLCBnZXROb3RGb3VuZCwgZ2V0U2VydmljZVVuYXZhaWxhYmxlLCBnZXRVbmF1dGhvcml6ZWQgfSBmcm9tICdAdmVyZGFjY2lvL2NvbW1vbnMtYXBpJztcbmltcG9ydCB7IFN0cmluZ1ZhbHVlIH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5pbXBvcnQgeyBBdXRob3IsIENvbmZpZywgUGFja2FnZSwgVmVyc2lvbiB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuXG5pbXBvcnQgeyBBdXRob3JBdmF0YXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBHRU5FUklDX0FWQVRBUiwgZ2VuZXJhdGVHcmF2YXRhclVybCB9IGZyb20gJy4uL3V0aWxzL3VzZXInO1xuaW1wb3J0IHsgQVBQX0VSUk9SLCBERUZBVUxUX0RPTUFJTiwgREVGQVVMVF9QT1JULCBERUZBVUxUX1BST1RPQ09MLCBERUZBVUxUX1VTRVIsIERJU1RfVEFHUywgSEVBREVSUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IG5vcm1hbGl6ZUNvbnRyaWJ1dG9ycyB9IGZyb20gJy4vc3RvcmFnZS11dGlscyc7XG5cbmNvbnN0IGRlYnVnID0gYnVpbGREZWJ1ZygndmVyZGFjY2lvJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG5yZXF1aXJlKCdwa2dpbmZvJykobW9kdWxlKTtcbmNvbnN0IHBrZ1ZlcnNpb24gPSBtb2R1bGUuZXhwb3J0cy52ZXJzaW9uO1xuY29uc3QgcGtnTmFtZSA9IG1vZHVsZS5leHBvcnRzLm5hbWU7XG5jb25zdCB2YWxpZFByb3RvY29scyA9IFsnaHR0cHMnLCAnaHR0cCddO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KGN1c3RvbVVzZXJBZ2VudD86IGJvb2xlYW4gfCBzdHJpbmcpOiBzdHJpbmcge1xuICBhc3NlcnQoXy5pc1N0cmluZyhwa2dOYW1lKSk7XG4gIGFzc2VydChfLmlzU3RyaW5nKHBrZ1ZlcnNpb24pKTtcbiAgaWYgKGN1c3RvbVVzZXJBZ2VudCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBgJHtwa2dOYW1lfS8ke3BrZ1ZlcnNpb259YDtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGN1c3RvbVVzZXJBZ2VudCkgJiYgXy5pc0VtcHR5KGN1c3RvbVVzZXJBZ2VudCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGN1c3RvbVVzZXJBZ2VudDtcbiAgfSBlbHNlIGlmIChjdXN0b21Vc2VyQWdlbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIGAke3BrZ05hbWV9LyR7cGtnVmVyc2lvbn1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFBheWxvYWRUb0Jhc2U2NChwYXlsb2FkOiBzdHJpbmcpOiBCdWZmZXIge1xuICByZXR1cm4gQnVmZmVyLmZyb20ocGF5bG9hZCwgJ2Jhc2U2NCcpO1xufVxuXG4vKipcbiAqIEZyb20gbm9ybWFsaXplLXBhY2thZ2UtZGF0YS9saWIvZml4ZXIuanNcbiAqIEBwYXJhbSB7Kn0gbmFtZSAgdGhlIHBhY2thZ2UgbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBpcyB2YWxpZCBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTmFtZShuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKF8uaXNTdHJpbmcobmFtZSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZE5hbWU6IHN0cmluZyA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAvKipcbiAgICogU29tZSBjb250ZXh0IGFib3V0IHRoZSBmaXJzdCByZWdleFxuICAgKiAtIG5wbSB1c2VkIHRvIGhhdmUgYSBkaWZmZXJlbnQgdGFyYmFsbCBuYW1pbmcgc3lzdGVtLlxuICAgKiBlZzogaHR0cDovL3JlZ2lzdHJ5Lm5wbWpzLmNvbS90aGlydHktdHdvXG4gICAqIGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3RoaXJ0eS10d28vLS90aGlydHktdHdvQDAuMC4xLnRnelxuICAgKiBUaGUgZmlsZSBuYW1lIHRoaXJ0eS10d29AMC4wLjEudGd6LCB0aGUgdmVyc2lvbiBhbmQgdGhlIHBrZyBuYW1lIHdhcyBzZXBhcmF0ZWQgYnkgYW4gYXQgKEApXG4gICAqIHdoaWxlIG5vd2FkYXlzIHRoZSBuYW1pbmcgc3lzdGVtIGlzIGJhc2VkIGluIGRhc2hlc1xuICAgKiBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy92ZXJkYWNjaW8vLS92ZXJkYWNjaW8tMS40LjAudGd6XG4gICAqXG4gICAqIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vcmxpZHdrYS9zaW5vcGlhL2lzc3Vlcy83NVxuICAgKi9cbiAgcmV0dXJuICEoXG4gICAgIW5vcm1hbGl6ZWROYW1lLm1hdGNoKC9eWy1hLXpBLVowLTlfLiF+KicoKUBdKyQvKSB8fFxuICAgIG5vcm1hbGl6ZWROYW1lLnN0YXJ0c1dpdGgoJy4nKSB8fCAvLyBcIi5iaW5cIiwgZXRjLlxuICAgIFsnbm9kZV9tb2R1bGVzJywgJ19fcHJvdG9fXycsICdmYXZpY29uLmljbyddLmluY2x1ZGVzKG5vcm1hbGl6ZWROYW1lKVxuICApO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgcGFja2FnZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIHBhY2thZ2UgaXMgdmFsaWQgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhY2thZ2UobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IG5hbWVMaXN0ID0gbmFtZS5zcGxpdCgnLycsIDIpO1xuICBpZiAobmFtZUxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gbm9ybWFsIHBhY2thZ2VcbiAgICByZXR1cm4gdmFsaWRhdGVOYW1lKG5hbWVMaXN0WzBdKTtcbiAgfVxuICAvLyBzY29wZWQgcGFja2FnZVxuICByZXR1cm4gbmFtZUxpc3RbMF1bMF0gPT09ICdAJyAmJiB2YWxpZGF0ZU5hbWUobmFtZUxpc3RbMF0uc2xpY2UoMSkpICYmIHZhbGlkYXRlTmFtZShuYW1lTGlzdFsxXSk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIE9iamVjdFxuICogQHBhcmFtIHsqfSBvYmogdGhlIGVsZW1lbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmo6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gXy5pc09iamVjdChvYmopICYmIF8uaXNOdWxsKG9iaikgPT09IGZhbHNlICYmIF8uaXNBcnJheShvYmopID09PSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0T3JBcnJheShvYmo6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gXy5pc09iamVjdChvYmopICYmIF8uaXNOdWxsKG9iaikgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBwYWNrYWdlIG1ldGFkYXRhLCBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdoZXRoZXIgYXJlIG1pc3Npbmcgd2l0aGluXG4gKiB0aGUgbWV0YWRhdGEgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcGFyYW0geyp9IG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcyBkaXN0LXRhZ3MgYWQgdmVyc2lvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTWV0YWRhdGEob2JqZWN0OiBQYWNrYWdlLCBuYW1lOiBzdHJpbmcpOiBQYWNrYWdlIHtcbiAgYXNzZXJ0KGlzT2JqZWN0KG9iamVjdCksICdub3QgYSBqc29uIG9iamVjdCcpO1xuICBhc3NlcnQuc3RyaWN0RXF1YWwob2JqZWN0Lm5hbWUsIG5hbWUpO1xuXG4gIGlmICghaXNPYmplY3Qob2JqZWN0W0RJU1RfVEFHU10pKSB7XG4gICAgb2JqZWN0W0RJU1RfVEFHU10gPSB7fTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3Qob2JqZWN0Wyd2ZXJzaW9ucyddKSkge1xuICAgIG9iamVjdFsndmVyc2lvbnMnXSA9IHt9O1xuICB9XG5cbiAgaWYgKCFpc09iamVjdChvYmplY3RbJ3RpbWUnXSkpIHtcbiAgICBvYmplY3RbJ3RpbWUnXSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUYXJiYWxsRnJvbVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIERlZmF1bHRVUkwucGFyc2UodXJsKS5wYXRobmFtZS5yZXBsYWNlKC9eLipcXC8vLCAnJyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBhIHBhY2thZ2VzJ3MgdmVyc2lvbnMgYW5kIGZpbHRlciBlYWNoIG9yaWdpbmFsIHRhcmJhbGwgdXJsLlxuICogQHBhcmFtIHsqfSBwa2dcbiAqIEBwYXJhbSB7Kn0gcmVxXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xuICogQHJldHVybiB7U3RyaW5nfSBhIGZpbHRlcmVkIHBhY2thZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREaXN0UmVtb3RlVG9Mb2NhbFRhcmJhbGxVcmxzKHBrZzogUGFja2FnZSwgcmVxOiBSZXF1ZXN0LCB1cmxQcmVmaXg6IHN0cmluZyB8IHZvaWQpOiBQYWNrYWdlIHtcbiAgZm9yIChjb25zdCB2ZXIgaW4gcGtnLnZlcnNpb25zKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwa2cudmVyc2lvbnMsIHZlcikpIHtcbiAgICAgIGNvbnN0IGRpc3ROYW1lID0gcGtnLnZlcnNpb25zW3Zlcl0uZGlzdDtcblxuICAgICAgaWYgKF8uaXNOdWxsKGRpc3ROYW1lKSA9PT0gZmFsc2UgJiYgXy5pc051bGwoZGlzdE5hbWUudGFyYmFsbCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGRpc3ROYW1lLnRhcmJhbGwgPSBnZXRMb2NhbFJlZ2lzdHJ5VGFyYmFsbFVyaShkaXN0TmFtZS50YXJiYWxsLCBwa2cubmFtZSwgcmVxLCB1cmxQcmVmaXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGtnO1xufVxuXG5jb25zdCBtZW1vaXplZGdldFB1YmxpY1VybCA9IG1lbW9pemVlKGdldFB1YmxpY1VybCk7XG5cbi8qKlxuICogRmlsdGVyIGEgdGFyYmFsbCB1cmwuXG4gKiBAcGFyYW0geyp9IHVyaVxuICogQHJldHVybiB7U3RyaW5nfSBhIHBhcnNlZCB1cmxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsUmVnaXN0cnlUYXJiYWxsVXJpKHVyaTogc3RyaW5nLCBwa2dOYW1lOiBzdHJpbmcsIHJlcTogUmVxdWVzdCwgdXJsUHJlZml4OiBzdHJpbmcgfCB2b2lkKTogc3RyaW5nIHtcbiAgY29uc3QgY3VycmVudEhvc3QgPSByZXEuZ2V0KCdob3N0Jyk7XG5cbiAgaWYgKCFjdXJyZW50SG9zdCkge1xuICAgIHJldHVybiB1cmk7XG4gIH1cbiAgY29uc3QgdGFyYmFsbE5hbWUgPSBleHRyYWN0VGFyYmFsbEZyb21VcmwodXJpKTtcbiAgY29uc3QgZG9tYWluUmVnaXN0cnkgPSBtZW1vaXplZGdldFB1YmxpY1VybCh1cmxQcmVmaXggfHwgJycsIHJlcSk7XG5cbiAgcmV0dXJuIGAke2RvbWFpblJlZ2lzdHJ5fSR7ZW5jb2RlU2NvcGVkVXJpKHBrZ05hbWUpfS8tLyR7dGFyYmFsbE5hbWV9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhZ1ZlcnNpb24oZGF0YTogUGFja2FnZSwgdmVyc2lvbjogc3RyaW5nLCB0YWc6IFN0cmluZ1ZhbHVlKTogYm9vbGVhbiB7XG4gIGlmICh0YWcgJiYgZGF0YVtESVNUX1RBR1NdW3RhZ10gIT09IHZlcnNpb24gJiYgc2VtdmVyLnBhcnNlKHZlcnNpb24sIHRydWUpKSB7XG4gICAgLy8gdmFsaWQgdmVyc2lvbiAtIHN0b3JlXG4gICAgZGF0YVtESVNUX1RBR1NdW3RhZ10gPSB2ZXJzaW9uO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXRzIHZlcnNpb24gZnJvbSBhIHBhY2thZ2Ugb2JqZWN0IHRha2luZyBpbnRvIGFjY291bnQgc2VtdmVyIHdlaXJkbmVzcy5cbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG9mIGEgcGFja2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVyc2lvbihwa2c6IFBhY2thZ2UsIHZlcnNpb246IGFueSk6IFZlcnNpb24gfCB2b2lkIHtcbiAgLy8gdGhpcyBjb25kaXRpb24gbXVzdCBhbGxvdyBjYXN0XG4gIGlmIChfLmlzTmlsKHBrZy52ZXJzaW9uc1t2ZXJzaW9uXSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHBrZy52ZXJzaW9uc1t2ZXJzaW9uXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmVyc2lvbiA9IHNlbXZlci5wYXJzZSh2ZXJzaW9uLCB0cnVlKTtcbiAgICBmb3IgKGNvbnN0IHZlcnNpb25JdGVtIGluIHBrZy52ZXJzaW9ucykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgaWYgKHZlcnNpb24uY29tcGFyZShzZW12ZXIucGFyc2UodmVyc2lvbkl0ZW0sIHRydWUpKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGtnLnZlcnNpb25zW3ZlcnNpb25JdGVtXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBpbnRlcm5ldCBhZGRyZXNzXG4gKiBBbGxvdzpcbiAtIGh0dHBzOmxvY2FsaG9zdDoxMjM0ICAgICAgICAtIHByb3RvY29sICsgaG9zdCArIHBvcnRcbiAtIGxvY2FsaG9zdDoxMjM0ICAgICAgICAgICAgICAtIGhvc3QgKyBwb3J0XG4gLSAxMjM0ICAgICAgICAgICAgICAgICAgICAgICAgLSBwb3J0XG4gLSBodHRwOjoxMjM0ICAgICAgICAgICAgICAgICAgLSBwcm90b2NvbCArIHBvcnRcbiAtIGh0dHBzOi8vbG9jYWxob3N0OjQ0My8gICAgICAtIGZ1bGwgdXJsICsgaHR0cHNcbiAtIGh0dHA6Ly9bOjoxXTo0NDMvICAgICAgICAgICAtIGlwdjZcbiAtIHVuaXg6L3RtcC9odHRwLnNvY2sgICAgICAgICAtIHVuaXggc29ja2V0c1xuIC0gaHR0cHM6Ly91bml4Oi90bXAvaHR0cC5zb2NrIC0gdW5peCBzb2NrZXRzIChodHRwcylcbiAqIEBwYXJhbSB7Kn0gdXJsQWRkcmVzcyB0aGUgaW50ZXJuZXQgYWRkcmVzcyBkZWZpbml0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R8TnVsbH0gbGl0ZXJhbCBvYmplY3QgdGhhdCByZXByZXNlbnQgdGhlIGFkZHJlc3MgcGFyc2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFkZHJlc3ModXJsQWRkcmVzczogYW55KTogYW55IHtcbiAgLy9cbiAgLy8gVE9ETzogcmVmYWN0b3IgaXQgdG8gc29tZXRoaW5nIG1vcmUgcmVhc29uYWJsZT9cbiAgLy9cbiAgLy8gICAgICAgIHByb3RvY29sIDogIC8vICAgICAgKCAgaG9zdCAgKXwoICAgIGlwdjYgICAgICk6ICBwb3J0ICAvXG4gIGxldCB1cmxQYXR0ZXJuID0gL14oKGh0dHBzPyk6KFxcL1xcLyk/KT8oKChbXlxcLzpdKil8XFxbKFteXFxbXFxdXSspXFxdKTopPyhcXGQrKVxcLz8kLy5leGVjKHVybEFkZHJlc3MpO1xuXG4gIGlmICh1cmxQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RvOiB1cmxQYXR0ZXJuWzJdIHx8IERFRkFVTFRfUFJPVE9DT0wsXG4gICAgICBob3N0OiB1cmxQYXR0ZXJuWzZdIHx8IHVybFBhdHRlcm5bN10gfHwgREVGQVVMVF9ET01BSU4sXG4gICAgICBwb3J0OiB1cmxQYXR0ZXJuWzhdIHx8IERFRkFVTFRfUE9SVCxcbiAgICB9O1xuICB9XG5cbiAgdXJsUGF0dGVybiA9IC9eKChodHRwcz8pOihcXC9cXC8pPyk/dW5peDooLiopJC8uZXhlYyh1cmxBZGRyZXNzKTtcblxuICBpZiAodXJsUGF0dGVybikge1xuICAgIHJldHVybiB7XG4gICAgICBwcm90bzogdXJsUGF0dGVyblsyXSB8fCBERUZBVUxUX1BST1RPQ09MLFxuICAgICAgcGF0aDogdXJsUGF0dGVybls0XSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZmlsdGVycyBvdXQgYmFkIHNlbXZlciB2ZXJzaW9ucyBhbmQgc29ydHMgdGhlIGFycmF5LlxuICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VtdmVyU29ydChsaXN0VmVyc2lvbnM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIGxpc3RWZXJzaW9uc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXNlbXZlci5wYXJzZSh4LCB0cnVlKSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKHsgdmVyOiB4IH0sICdpZ25vcmluZyBiYWQgdmVyc2lvbiBAe3Zlcn0nKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KVxuICAgICAgLy8gRklYTUU6IGl0IHNlZW1zIHRoZSBAdHlwZXMvc2VtdmVyIGRvIG5vdCBoYW5kbGUgYSBsZWdpdGltYXRlIG1ldGhvZCBuYW1lZCAnY29tcGFyZUxvb3NlJ1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLnNvcnQoc2VtdmVyLmNvbXBhcmVMb29zZSlcbiAgICAgIC5tYXAoU3RyaW5nKVxuICApO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYXJyYXlzIG9mIHRhZ3MuXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZURpc3RUYWdzKHBrZzogUGFja2FnZSk6IHZvaWQge1xuICBsZXQgc29ydGVkO1xuICBpZiAoIXBrZ1tESVNUX1RBR1NdLmxhdGVzdCkge1xuICAgIC8vIG92ZXJ3cml0ZSBsYXRlc3Qgd2l0aCBoaWdoZXN0IGtub3duIHZlcnNpb24gYmFzZWQgb24gc2VtdmVyIHNvcnRcbiAgICBzb3J0ZWQgPSBzZW12ZXJTb3J0KE9iamVjdC5rZXlzKHBrZy52ZXJzaW9ucykpO1xuICAgIGlmIChzb3J0ZWQgJiYgc29ydGVkLmxlbmd0aCkge1xuICAgICAgcGtnW0RJU1RfVEFHU10ubGF0ZXN0ID0gc29ydGVkLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgdGFnIGluIHBrZ1tESVNUX1RBR1NdKSB7XG4gICAgaWYgKF8uaXNBcnJheShwa2dbRElTVF9UQUdTXVt0YWddKSkge1xuICAgICAgaWYgKHBrZ1tESVNUX1RBR1NdW3RhZ10ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHNvcnQgYXJyYXlcbiAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgY2xlYXJseSB3cm9uZywgd2UgbmVlZCB0byByZXNlYXJjaCB3aHkgdGhpcyBpcyBsaWtlIHRoaXMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc29ydGVkID0gc2VtdmVyU29ydChwa2dbRElTVF9UQUdTXVt0YWddKTtcbiAgICAgICAgaWYgKHNvcnRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyB1c2UgaGlnaGVzdCB2ZXJzaW9uIGJhc2VkIG9uIHNlbXZlciBzb3J0XG4gICAgICAgICAgcGtnW0RJU1RfVEFHU11bdGFnXSA9IHNvcnRlZC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHBrZ1tESVNUX1RBR1NdW3RhZ107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHBrZ1tESVNUX1RBR1NdW3RhZ10pKSB7XG4gICAgICBpZiAoIXNlbXZlci5wYXJzZShwa2dbRElTVF9UQUdTXVt0YWddLCB0cnVlKSkge1xuICAgICAgICAvLyBpZiB0aGUgdmVyc2lvbiBpcyBpbnZhbGlkLCBkZWxldGUgdGhlIGRpc3QtdGFnIGVudHJ5XG4gICAgICAgIGRlbGV0ZSBwa2dbRElTVF9UQUdTXVt0YWddO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwYXJzZUludGVydmFsVGFibGUgPSB7XG4gICcnOiAxMDAwLFxuICBtczogMSxcbiAgczogMTAwMCxcbiAgbTogNjAgKiAxMDAwLFxuICBoOiA2MCAqIDYwICogMTAwMCxcbiAgZDogODY0MDAwMDAsXG4gIHc6IDcgKiA4NjQwMDAwMCxcbiAgTTogMzAgKiA4NjQwMDAwMCxcbiAgeTogMzY1ICogODY0MDAwMDAsXG59O1xuXG4vKipcbiAqIFBhcnNlIGFuIGludGVybmFsIHN0cmluZyB0byBudW1iZXJcbiAqIEBwYXJhbSB7Kn0gaW50ZXJ2YWxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZXJ2YWwoaW50ZXJ2YWw6IGFueSk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGludGVydmFsICogMTAwMDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gMDtcbiAgbGV0IGxhc3Rfc3VmZml4ID0gSW5maW5pdHk7XG4gIGludGVydmFsLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoeCk6IHZvaWQge1xuICAgIGlmICgheCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtID0geC5tYXRjaCgvXigoMHxbMS05XVswLTldKikoXFwuWzAtOV0rKT8pKG1zfHN8bXxofGR8d3xNfHl8KSQvKTtcbiAgICBpZiAoIW0gfHwgcGFyc2VJbnRlcnZhbFRhYmxlW21bNF1dID49IGxhc3Rfc3VmZml4IHx8IChtWzRdID09PSAnJyAmJiBsYXN0X3N1ZmZpeCAhPT0gSW5maW5pdHkpKSB7XG4gICAgICB0aHJvdyBFcnJvcignaW52YWxpZCBpbnRlcnZhbDogJyArIGludGVydmFsKTtcbiAgICB9XG4gICAgbGFzdF9zdWZmaXggPSBwYXJzZUludGVydmFsVGFibGVbbVs0XV07XG4gICAgcmVzdWx0ICs9IE51bWJlcihtWzFdKSAqIHBhcnNlSW50ZXJ2YWxUYWJsZVttWzRdXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZWN0IHJ1bm5pbmcgcHJvdG9jb2wgKGh0dHAgb3IgaHR0cHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWJQcm90b2NvbChoZWFkZXJQcm90b2NvbDogc3RyaW5nIHwgdm9pZCwgcHJvdG9jb2w6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCByZXR1cm5Qcm90b2NvbDtcbiAgY29uc3QgWywgZGVmYXVsdFByb3RvY29sXSA9IHZhbGlkUHJvdG9jb2xzO1xuICAvLyBIQVByb3h5IHZhcmlhbnQgbWlnaHQgcmV0dXJuIGh0dHAsaHR0cCB3aXRoIFgtRm9yd2FyZGVkLVByb3RvXG4gIGlmICh0eXBlb2YgaGVhZGVyUHJvdG9jb2wgPT09ICdzdHJpbmcnICYmIGhlYWRlclByb3RvY29sICE9PSAnJykge1xuICAgIGRlYnVnKCdoZWFkZXIgcHJvdG9jb2w6ICVvJywgcHJvdG9jb2wpO1xuICAgIGNvbnN0IGNvbW1hSW5kZXggPSBoZWFkZXJQcm90b2NvbC5pbmRleE9mKCcsJyk7XG4gICAgcmV0dXJuUHJvdG9jb2wgPSBjb21tYUluZGV4ID4gMCA/IGhlYWRlclByb3RvY29sLnN1YnN0cigwLCBjb21tYUluZGV4KSA6IGhlYWRlclByb3RvY29sO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdyZXEgcHJvdG9jb2w6ICVvJywgaGVhZGVyUHJvdG9jb2wpO1xuICAgIHJldHVyblByb3RvY29sID0gcHJvdG9jb2w7XG4gIH1cblxuICByZXR1cm4gdmFsaWRQcm90b2NvbHMuaW5jbHVkZXMocmV0dXJuUHJvdG9jb2wpID8gcmV0dXJuUHJvdG9jb2wgOiBkZWZhdWx0UHJvdG9jb2w7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXRlc3RWZXJzaW9uKHBrZ0luZm86IFBhY2thZ2UpOiBzdHJpbmcge1xuICByZXR1cm4gcGtnSW5mb1tESVNUX1RBR1NdLmxhdGVzdDtcbn1cblxuZXhwb3J0IGNvbnN0IEVycm9yQ29kZSA9IHtcbiAgZ2V0Q29uZmxpY3QsXG4gIGdldEJhZERhdGEsXG4gIGdldEJhZFJlcXVlc3QsXG4gIGdldEludGVybmFsRXJyb3IsXG4gIGdldFVuYXV0aG9yaXplZCxcbiAgZ2V0Rm9yYmlkZGVuLFxuICBnZXRTZXJ2aWNlVW5hdmFpbGFibGUsXG4gIGdldE5vdEZvdW5kLFxuICBnZXRDb2RlLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29uZmlnRmlsZShjb25maWdQYXRoOiBzdHJpbmcpOiBhbnkge1xuICB0cnkge1xuICAgIGlmICgvXFwueWE/bWwkL2kudGVzdChjb25maWdQYXRoKSkge1xuICAgICAgcmV0dXJuIFlBTUwubG9hZChmcy5yZWFkRmlsZVN5bmMoY29uZmlnUGF0aCwgJ3V0Zi04JykpO1xuICAgIH1cbiAgICBkZWJ1ZygneWFtbCBwYXJzZWQnKTtcbiAgICByZXR1cm4gcmVxdWlyZShjb25maWdQYXRoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCd5YW1sIHBhcnNlIGZhaWxlZCcpO1xuICAgIGlmIChlLmNvZGUgIT09ICdNT0RVTEVfTk9UX0ZPVU5EJykge1xuICAgICAgZS5tZXNzYWdlID0gQVBQX0VSUk9SLkNPTkZJR19OT1RfVkFMSUQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgcGF0aCBhbHJlYWR5IGV4aXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb2xkZXJFeGlzdHMocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKHBhdGgpO1xuICAgIHJldHVybiBzdGF0LmlzRGlyZWN0b3J5KCk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBmaWxlIGFscmVhZHkgZXhpc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGVFeGlzdHMocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKHBhdGgpO1xuICAgIHJldHVybiBzdGF0LmlzRmlsZSgpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0QnlOYW1lKHBhY2thZ2VzOiBhbnlbXSwgb3JkZXJBc2NlbmRpbmc6IGJvb2xlYW4gfCB2b2lkID0gdHJ1ZSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIHBhY2thZ2VzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYik6IG51bWJlciB7XG4gICAgY29uc3QgY29tcGFyYXRvck5hbWVzID0gYS5uYW1lLnRvTG93ZXJDYXNlKCkgPCBiLm5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIHJldHVybiBvcmRlckFzY2VuZGluZyA/IChjb21wYXJhdG9yTmFtZXMgPyAtMSA6IDEpIDogY29tcGFyYXRvck5hbWVzID8gMSA6IC0xO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFNjb3BlKHNjb3BlOiBzdHJpbmcsIHBhY2thZ2VOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYEAke3Njb3BlfS8ke3BhY2thZ2VOYW1lfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0aWVzKHByb3BlcnRpZXNUb0RlbGV0ZTogc3RyaW5nW10sIG9iamVjdEl0ZW06IGFueSk6IGFueSB7XG4gIF8uZm9yRWFjaChwcm9wZXJ0aWVzVG9EZWxldGUsIChwcm9wZXJ0eSk6IGFueSA9PiB7XG4gICAgZGVsZXRlIG9iamVjdEl0ZW1bcHJvcGVydHldO1xuICB9KTtcblxuICByZXR1cm4gb2JqZWN0SXRlbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEdyYXZhdGFyU3VwcG9ydChwa2dJbmZvOiBQYWNrYWdlLCBvbmxpbmUgPSB0cnVlKTogQXV0aG9yQXZhdGFyIHtcbiAgY29uc3QgcGtnSW5mb0NvcHkgPSB7IC4uLnBrZ0luZm8gfSBhcyBhbnk7XG4gIGNvbnN0IGF1dGhvcjogYW55ID0gXy5nZXQocGtnSW5mbywgJ2xhdGVzdC5hdXRob3InLCBudWxsKSBhcyBhbnk7XG4gIGNvbnN0IGNvbnRyaWJ1dG9yczogQXV0aG9yQXZhdGFyW10gPSBub3JtYWxpemVDb250cmlidXRvcnMoXy5nZXQocGtnSW5mbywgJ2xhdGVzdC5jb250cmlidXRvcnMnLCBbXSkpO1xuICBjb25zdCBtYWludGFpbmVycyA9IF8uZ2V0KHBrZ0luZm8sICdsYXRlc3QubWFpbnRhaW5lcnMnLCBbXSk7XG5cbiAgLy8gZm9yIGF1dGhvci5cbiAgaWYgKGF1dGhvciAmJiBfLmlzT2JqZWN0KGF1dGhvcikpIHtcbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhdXRob3IgYXMgQXV0aG9yO1xuICAgIHBrZ0luZm9Db3B5LmxhdGVzdC5hdXRob3IuYXZhdGFyID0gZ2VuZXJhdGVHcmF2YXRhclVybChlbWFpbCwgb25saW5lKTtcbiAgfVxuXG4gIGlmIChhdXRob3IgJiYgXy5pc1N0cmluZyhhdXRob3IpKSB7XG4gICAgcGtnSW5mb0NvcHkubGF0ZXN0LmF1dGhvciA9IHtcbiAgICAgIGF2YXRhcjogR0VORVJJQ19BVkFUQVIsXG4gICAgICBlbWFpbDogJycsXG4gICAgICBhdXRob3IsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGZvciBjb250cmlidXRvcnNcbiAgaWYgKF8uaXNFbXB0eShjb250cmlidXRvcnMpID09PSBmYWxzZSkge1xuICAgIHBrZ0luZm9Db3B5LmxhdGVzdC5jb250cmlidXRvcnMgPSBjb250cmlidXRvcnMubWFwKChjb250cmlidXRvcik6IEF1dGhvckF2YXRhciA9PiB7XG4gICAgICBpZiAoaXNPYmplY3QoY29udHJpYnV0b3IpKSB7XG4gICAgICAgIGNvbnRyaWJ1dG9yLmF2YXRhciA9IGdlbmVyYXRlR3JhdmF0YXJVcmwoY29udHJpYnV0b3IuZW1haWwsIG9ubGluZSk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoY29udHJpYnV0b3IpKSB7XG4gICAgICAgIGNvbnRyaWJ1dG9yID0ge1xuICAgICAgICAgIGF2YXRhcjogR0VORVJJQ19BVkFUQVIsXG4gICAgICAgICAgZW1haWw6IGNvbnRyaWJ1dG9yLFxuICAgICAgICAgIG5hbWU6IGNvbnRyaWJ1dG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udHJpYnV0b3I7XG4gICAgfSk7XG4gIH1cblxuICAvLyBmb3IgbWFpbnRhaW5lcnNcbiAgaWYgKF8uaXNFbXB0eShtYWludGFpbmVycykgPT09IGZhbHNlKSB7XG4gICAgcGtnSW5mb0NvcHkubGF0ZXN0Lm1haW50YWluZXJzID0gbWFpbnRhaW5lcnMubWFwKChtYWludGFpbmVyKTogdm9pZCA9PiB7XG4gICAgICBtYWludGFpbmVyLmF2YXRhciA9IGdlbmVyYXRlR3JhdmF0YXJVcmwobWFpbnRhaW5lci5lbWFpbCwgb25saW5lKTtcbiAgICAgIHJldHVybiBtYWludGFpbmVyO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBrZ0luZm9Db3B5O1xufVxuXG4vKipcbiAqIHBhcnNlIHBhY2thZ2UgcmVhZG1lIC0gbWFya2Rvd24vYXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrYWdlTmFtZSBuYW1lIG9mIHBhY2thZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFkbWUgcGFja2FnZSByZWFkbWVcblxuICogQHJldHVybiB7U3RyaW5nfSBjb252ZXJ0ZWQgaHRtbCB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWFkbWUocGFja2FnZU5hbWU6IHN0cmluZywgcmVhZG1lOiBzdHJpbmcpOiBzdHJpbmcgfCB2b2lkIHtcbiAgaWYgKF8uaXNFbXB0eShyZWFkbWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFkbWU7XG4gIH1cblxuICAvLyBsb2dzIHJlYWRtZSBub3QgZm91bmQgZXJyb3JcbiAgbG9nZ2VyLmluZm8oeyBwYWNrYWdlTmFtZSB9LCAnQHtwYWNrYWdlTmFtZX06IE5vIHJlYWRtZSBmb3VuZCcpO1xuXG4gIHJldHVybiAnRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kISc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFRva2VuKHR5cGU6IHN0cmluZywgdG9rZW46IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtfLmNhcGl0YWxpemUodHlwZSl9ICR7dG9rZW59YDtcbn1cblxuLyoqXG4gKiByZXR1cm4gcGFja2FnZSB2ZXJzaW9uIGZyb20gdGFyYmFsbCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnNpb25Gcm9tVGFyYmFsbChuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB2b2lkIHtcbiAgLy8gRklYTUU6IHdlIGtub3cgdGhlIHJlZ2V4IGlzIHZhbGlkLCBidXQgd2Ugc2hvdWxkIGltcHJvdmUgdGhpcyBwYXJ0IGFzIHRzIHN1Z2dlc3RcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gLy4rLShcXGQuKylcXC50Z3ovLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC8uKy0oXFxkLispXFwudGd6LylbMV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCB0eXBlIEF1dGhvckZvcm1hdCA9IEF1dGhvciB8IHN0cmluZyB8IG51bGwgfCBvYmplY3QgfCB2b2lkO1xuXG4vKipcbiAqIEZvcm1hdHMgYXV0aG9yIGZpZWxkIGZvciB3ZWJ1aS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9maWxlcy9wYWNrYWdlLmpzb24jYXV0aG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R8dW5kZWZpbmVkfSBhdXRob3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEF1dGhvcihhdXRob3I6IEF1dGhvckZvcm1hdCk6IGFueSB7XG4gIGxldCBhdXRob3JEZXRhaWxzID0ge1xuICAgIG5hbWU6IERFRkFVTFRfVVNFUixcbiAgICBlbWFpbDogJycsXG4gICAgdXJsOiAnJyxcbiAgfTtcblxuICBpZiAoXy5pc05pbChhdXRob3IpKSB7XG4gICAgcmV0dXJuIGF1dGhvckRldGFpbHM7XG4gIH1cblxuICBpZiAoXy5pc1N0cmluZyhhdXRob3IpKSB7XG4gICAgYXV0aG9yRGV0YWlscyA9IHtcbiAgICAgIC4uLmF1dGhvckRldGFpbHMsXG4gICAgICBuYW1lOiBhdXRob3IgYXMgc3RyaW5nLFxuICAgIH07XG4gIH1cblxuICBpZiAoXy5pc09iamVjdChhdXRob3IpKSB7XG4gICAgYXV0aG9yRGV0YWlscyA9IHtcbiAgICAgIC4uLmF1dGhvckRldGFpbHMsXG4gICAgICAuLi4oYXV0aG9yIGFzIEF1dGhvciksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBhdXRob3JEZXRhaWxzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIFVSSSBpcyBzdGFydGluZyB3aXRoIFwiaHR0cDovL1wiLCBcImh0dHBzOi8vXCIgb3IgXCIvL1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hUVFBQcm90b2NvbCh1cmk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL14oaHR0cHM/Oik/XFwvXFwvLy50ZXN0KHVyaSk7XG59XG5cbi8qKlxuICogQXBwbHkgd2hpdGVzcGFjZXMgYmFzZWQgb24gdGhlIGxlbmd0aFxuICogQHBhcmFtIHsqfSBzdHIgdGhlIGxvZyBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWQoc3RyLCBtYXgpOiBzdHJpbmcge1xuICBpZiAoc3RyLmxlbmd0aCA8IG1heCkge1xuICAgIHJldHVybiBzdHIgKyAnICcucmVwZWF0KG1heCAtIHN0ci5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogcmV0dXJuIGEgbWFzcXVlcmFkZSBzdHJpbmcgd2l0aCBpdHMgZmlyc3QgYW5kIGxhc3Qge2NoYXJOdW19IGFuZCB0aHJlZSBkb3RzIGluIGJldHdlZW4uXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhck51bVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soc3RyOiBzdHJpbmcsIGNoYXJOdW0gPSAzKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke3N0ci5zdWJzdHIoMCwgY2hhck51bSl9Li4uJHtzdHIuc3Vic3RyKC1jaGFyTnVtKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlU2NvcGVkVXJpKHBhY2thZ2VOYW1lKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhY2thZ2VOYW1lLnJlcGxhY2UoL1xcLy9nLCAnJTJmJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNEaWZmT25lS2V5KHZlcnNpb25zKTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2ZXJzaW9ucykubGVuZ3RoICE9PSAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWZXJzaW9uVmFsaWQocGFja2FnZU1ldGEsIHBhY2thZ2VWZXJzaW9uKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhhc1ZlcnNpb24gPSB0eXBlb2YgcGFja2FnZVZlcnNpb24gIT09ICd1bmRlZmluZWQnO1xuICBpZiAoIWhhc1ZlcnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBoYXNNYXRjaFZlcnNpb24gPSBPYmplY3Qua2V5cyhwYWNrYWdlTWV0YS52ZXJzaW9ucykuaW5jbHVkZXMocGFja2FnZVZlcnNpb24pO1xuICByZXR1cm4gaGFzTWF0Y2hWZXJzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWxhdGVkVG9EZXByZWNhdGlvbihwa2dJbmZvOiBQYWNrYWdlKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgdmVyc2lvbnMgfSA9IHBrZ0luZm87XG4gIGZvciAoY29uc3QgdmVyc2lvbiBpbiB2ZXJzaW9ucykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmVyc2lvbnNbdmVyc2lvbl0sICdkZXByZWNhdGVkJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVSTChwdWJsaWNVcmw6IHN0cmluZyB8IHZvaWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKHB1YmxpY1VybCBhcyBzdHJpbmcpO1xuICAgIGlmICghdmFsaWRQcm90b2NvbHMuaW5jbHVkZXMocGFyc2VkLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJykpKSB7XG4gICAgICB0aHJvdyBFcnJvcignaW52YWxpZCBwcm90b2NvbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gVE9ETzogYWRkIGVycm9yIGxvZ2dlciBoZXJlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hvc3QodXJsOiBzdHJpbmcgPSAnJywgb3B0aW9ucyA9IHt9KTogYm9vbGVhbiB7XG4gIHJldHVybiB2YWxpZGF0b3IuaXNVUkwodXJsLCB7XG4gICAgcmVxdWlyZV9ob3N0OiB0cnVlLFxuICAgIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2UsXG4gICAgcmVxdWlyZV92YWxpZF9wcm90b2NvbDogZmFsc2UsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJlcXVpcmVfcG9ydDogZmFsc2UsXG4gICAgcmVxdWlyZV90bGQ6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljVXJsKHVybF9wcmVmaXg6IHN0cmluZyA9ICcnLCByZXEpOiBzdHJpbmcge1xuICBpZiAodmFsaWRhdGVVUkwocHJvY2Vzcy5lbnYuVkVSREFDQ0lPX1BVQkxJQ19VUkwgYXMgc3RyaW5nKSkge1xuICAgIGNvbnN0IGVudlVSTCA9IG5ldyBVUkwod3JhcFByZWZpeCh1cmxfcHJlZml4KSwgcHJvY2Vzcy5lbnYuVkVSREFDQ0lPX1BVQkxJQ19VUkwgYXMgc3RyaW5nKS5ocmVmO1xuICAgIGRlYnVnKCdwdWJsaWMgdXJsIGJ5IGVudiAlbycsIGVudlVSTCk7XG4gICAgcmV0dXJuIGVudlVSTDtcbiAgfSBlbHNlIGlmIChyZXEuZ2V0KCdob3N0JykpIHtcbiAgICBjb25zdCBob3N0ID0gcmVxLmdldCgnaG9zdCcpO1xuICAgIGlmICghaXNIb3N0KGhvc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaG9zdCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm90b0hlYWRlciA9IHByb2Nlc3MuZW52LlZFUkRBQ0NJT19GT1JXQVJERURfUFJPVE8gPz8gSEVBREVSUy5GT1JXQVJERURfUFJPVE87XG4gICAgY29uc3QgcHJvdG9jb2wgPSBnZXRXZWJQcm90b2NvbChyZXEuZ2V0KHByb3RvSGVhZGVyLnRvTG93ZXJDYXNlKCkpLCByZXEucHJvdG9jb2wpO1xuICAgIGNvbnN0IGNvbWJpbmVkVXJsID0gY29tYmluZUJhc2VVcmwocHJvdG9jb2wsIGhvc3QsIHVybF9wcmVmaXgpO1xuICAgIGRlYnVnKCdwdWJsaWMgdXJsIGJ5IHJlcXVlc3QgJW8nLCBjb21iaW5lZFVybCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnLyc7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYmFzZSB1cmwgZm9yIHJlZ2lzdHJ5LlxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlIHJlZ2lzdHJ5IHVybFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUJhc2VVcmwocHJvdG9jb2w6IHN0cmluZywgaG9zdDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyA9ICcnKTogc3RyaW5nIHtcbiAgZGVidWcoJ2NvbWJpbmVkIHByb3RvY29sICVvJywgcHJvdG9jb2wpO1xuICBkZWJ1ZygnY29tYmluZWQgaG9zdCAlbycsIGhvc3QpO1xuICBjb25zdCBuZXdQcmVmaXggPSB3cmFwUHJlZml4KHByZWZpeCk7XG4gIGRlYnVnKCdjb21iaW5lZCBwcmVmaXggJW8nLCBuZXdQcmVmaXgpO1xuICBjb25zdCBncm91cGVkVVJJID0gbmV3IFVSTCh3cmFwUHJlZml4KHByZWZpeCksIGAke3Byb3RvY29sfTovLyR7aG9zdH1gKTtcbiAgY29uc3QgcmVzdWx0ID0gZ3JvdXBlZFVSSS5ocmVmO1xuICBkZWJ1ZygnY29tYmluZWQgdXJsICVvJywgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQcmVmaXgocHJlZml4OiBzdHJpbmcgfCB2b2lkKTogc3RyaW5nIHtcbiAgaWYgKHByZWZpeCA9PT0gJycgfHwgdHlwZW9mIHByZWZpeCA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJlZml4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2UgaWYgKCFwcmVmaXguc3RhcnRzV2l0aCgnLycpICYmIHByZWZpeC5lbmRzV2l0aCgnLycpKSB7XG4gICAgcmV0dXJuIGAvJHtwcmVmaXh9YDtcbiAgfSBlbHNlIGlmICghcHJlZml4LnN0YXJ0c1dpdGgoJy8nKSAmJiAhcHJlZml4LmVuZHNXaXRoKCcvJykpIHtcbiAgICByZXR1cm4gYC8ke3ByZWZpeH0vYDtcbiAgfSBlbHNlIGlmIChwcmVmaXguc3RhcnRzV2l0aCgnLycpICYmICFwcmVmaXguZW5kc1dpdGgoJy8nKSkge1xuICAgIHJldHVybiBgJHtwcmVmaXh9L2A7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzTG9naW4oY29uZmlnOiBDb25maWcpIHtcbiAgLy8gRklYTUU6IHR5cGVzIGFyZSBub3QgeWV0IG9uIHRoZSBsaWJyYXJ5IHZlcmRhY2Npby9tb25vcmVwb1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBfLmlzTmlsKGNvbmZpZz8ud2ViPy5sb2dpbikgfHwgY29uZmlnPy53ZWI/LmxvZ2luID09PSB0cnVlO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQXdEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFeEQsTUFBTUEsS0FBSyxHQUFHLElBQUFDLGNBQVUsRUFBQyxXQUFXLENBQUM7O0FBRXJDO0FBQ0E7QUFDQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDQyxNQUFNLENBQUM7QUFDMUIsTUFBTUMsVUFBVSxHQUFHRCxNQUFNLENBQUNFLE9BQU8sQ0FBQ0MsT0FBTztBQUN6QyxNQUFNQyxPQUFPLEdBQUdKLE1BQU0sQ0FBQ0UsT0FBTyxDQUFDRyxJQUFJO0FBQ25DLE1BQU1DLGNBQWMsR0FBRyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUM7QUFFakMsU0FBU0MsWUFBWSxDQUFDQyxlQUFrQyxFQUFVO0VBQ3ZFLElBQUFDLGVBQU0sRUFBQ0MsZUFBQyxDQUFDQyxRQUFRLENBQUNQLE9BQU8sQ0FBQyxDQUFDO0VBQzNCLElBQUFLLGVBQU0sRUFBQ0MsZUFBQyxDQUFDQyxRQUFRLENBQUNWLFVBQVUsQ0FBQyxDQUFDO0VBQzlCLElBQUlPLGVBQWUsS0FBSyxJQUFJLEVBQUU7SUFDNUIsT0FBUSxHQUFFSixPQUFRLElBQUdILFVBQVcsRUFBQztFQUNuQyxDQUFDLE1B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